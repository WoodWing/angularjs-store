{"version":3,"file":"angularjs-store.min.js","sources":["../../src/models/hook.ts","../../src/models/hook-link.ts","../../src/angularjs-store.ts","../../src/models/state-holder.ts"],"sourcesContent":["export type HookMatcher = (action: string) => boolean;\n\nexport type HookCallback<State> = (state: Readonly<State>, initialRun: boolean) => void;\n\nexport default class Hook<State> {\n  private $$match: HookMatcher;\n  private $$callback: HookCallback<State>;\n  private $$called = false;\n\n  /**\n   * Create a Hook.\n   * @param matcher Function that test the dispatched action.\n   * @param callback Callback function that trigger when action passed to matcher.\n   */\n  constructor(matcher: HookMatcher, callback: HookCallback<State>) {\n    this.$$match = matcher;\n    this.$$callback = callback;\n  }\n\n  /**\n   * Run the registered callback when action passed to matcher.\n   * @param action Action name.\n   * @param state A state to pass in callback.\n   */\n  public run(state: Readonly<State>) {\n    this.$$callback(state, !this.$$called);\n    this.$$called = true;\n  }\n\n  public matches = (action: string) => this.$$match(action);\n}\n","import { IScope } from 'angular';\n\nexport default class HookLink {\n  private $$destroyer: () => void;\n\n  /**\n   * Create a HookLink.\n   * @param destroyer Destroyer function.\n   */\n  constructor(destroyer: () => void) {\n    this.$$destroyer = destroyer;\n  }\n\n  /**\n   * Invoke the destroyer function.\n   */\n  public destroy() {\n    this.$$destroyer();\n  }\n\n  /**\n   * Bind hook to scope. Automatically destroy the hook link when scope destroyed.\n   * @param scope The scope where to bound the HookLink.\n   */\n  public destroyOn(scope: IScope) {\n    scope.$on('$destroy', () => {\n      this.$$destroyer();\n    });\n  }\n}\n","import Hook, { HookCallback, HookMatcher } from './models/hook';\nimport HookLink from './models/hook-link';\nimport holdState, { StateHolder } from './models/state-holder';\n\n/* istanbul ignore next */\nif (__DEV__) {\n  if (!angular) {\n    console.warn('Seems like you forgot to load angular. Make sure to load it first before the angularjs-store.');\n  }\n}\n\nexport type HookActionQuery<Actions extends string[] = string[]> =\n  | '*'\n  | Actions[number]\n  | Array<Actions[number] | '*'>\n  | RegExp;\n\ntype StateFactory<T> = (prevState: T) => Partial<T>;\n\nexport default class NgStore<State extends { [key: string]: any } = {}, Actions extends string[] = string[]> {\n  private $$stateHolder: StateHolder<State>;\n\n  /**\n   * All registered hooks from the store.\n   */\n  private $$hooks: Array<Hook<State>> = [];\n\n  /**\n   * Create a Store.\n   * @param initialState Initial state value.\n   */\n  constructor(initialState: State) {\n    /* istanbul ignore next */\n    if (__DEV__) {\n      if (Object.prototype.toString.call(initialState) !== '[object Object]') {\n        console.warn(\n          'Initializing the store with a non-object state is not recommended.\\n',\n          \"If you're trying to create a store with primitive type of state, try to wrap it with object.\",\n        );\n      }\n    }\n\n    this.$$stateHolder = holdState(initialState);\n  }\n\n  /**\n   * Get a new copy of state.\n   */\n  public copy(): State {\n    return this.$$stateHolder.get();\n  }\n\n  /**\n   * Attach a hook to the store and get notified everytime the given query matched to dispatched action.\n   * @param query A query for the dispatched action.\n   * @param callback Invoke when query match to dispatched action.\n   */\n  public hook(query: HookActionQuery<Actions>, callback: HookCallback<State>) {\n    let matcher: HookMatcher;\n\n    if (typeof query === 'string') {\n      matcher = query === '*' ? () => true : (action) => action === query;\n    } else if (Array.isArray(query)) {\n      /* istanbul ignore next */\n      if (__DEV__) {\n        const nonStringQueryItem = query.find((queryItem) => typeof queryItem !== 'string');\n\n        if (nonStringQueryItem) {\n          console.warn(\n            `Hook action query contains non-string value (${nonStringQueryItem}).\\n`,\n            'Using array as query must only contains string.',\n          );\n        }\n      }\n\n      matcher = (action) => query.includes(action);\n    } else if (query instanceof RegExp) {\n      matcher = (action) => query.test(action);\n    } else {\n      /* istanbul ignore next */\n      if (__DEV__) {\n        throw new Error('Hook action query must be a either string, array of string, or regular expression.');\n      }\n\n      /* istanbul ignore next */\n      throw new TypeError('Invalid hook query.');\n    }\n\n    if (!angular.isFunction(callback)) {\n      /* istanbul ignore next */\n      if (__DEV__) {\n        throw new Error('Hook callback must be a function.');\n      }\n\n      /* istanbul ignore next */\n      throw new TypeError('Invalid hook callback.');\n    }\n\n    const hook = new Hook<State>(matcher, callback);\n\n    this.$$hooks.push(hook);\n\n    // Initial run of hook.\n    hook.run(this.$$stateHolder.get());\n\n    return new HookLink(() => {\n      this.$$hooks.splice(this.$$hooks.indexOf(hook), 1);\n    });\n  }\n\n  /**\n   * Dispatch an action for updating state.\n   * @param action Action name.\n   * @param state New state of store.\n   */\n  public dispatch(action: Actions[number], state: Partial<State>): void;\n\n  /**\n   * Dispatch an action for updating state.\n   * @param action Action name.\n   * @param setState State setter.\n   */\n  public dispatch(action: Actions[number], setState: StateFactory<State>): void;\n\n  /**\n   * Implementation.\n   */\n  public dispatch(action: Actions[number], state: Partial<State> | StateFactory<State>) {\n    const partialState: Partial<State> = angular.isFunction(state)\n      ? (state as StateFactory<State>)(this.$$stateHolder.get())\n      : state as Partial<State>;\n\n    /* istanbul ignore next */\n    if (__DEV__) {\n      if (Object.prototype.toString.call(partialState) !== '[object Object]') {\n        console.warn(\n          \"You're about to update the state using a non-object value.\\n\",\n          'Did you use non-object state?\\n',\n          \"If yes, it's not recommended.\\n\",\n          'Primitive type state must wrap with object.',\n        );\n      }\n    }\n\n    this.$$stateHolder.set(partialState);\n\n    // Only create one copy of the state for all hooks for performance reasons, hooks should never modify the passed state object\n    const newState = this.$$stateHolder.get();\n\n    this.$$hooks\n      .filter(hook => hook.matches(action))\n      .forEach(hook => {\n        hook.run(newState);\n      });\n  }\n}\n","export interface StateHolder<State> {\n  /**\n   * Get a new copy of state.\n   */\n  get(): State;\n\n  /**\n   * Update the current state.\n   * @param partialState New partial state.\n   */\n  set(partialState: Partial<State>): void;\n}\n\nexport default function holdState<State>(state: State): StateHolder<State> {\n  const $$state = angular.copy(state);\n\n  const get = () => {\n    return angular.copy($$state);\n  };\n\n  const set = (partialState: Partial<State>) => {\n    for (const key in partialState) {\n      if (partialState.hasOwnProperty(key) && key in $$state) {\n        $$state[key] = angular.copy(partialState[key])!;\n      }\n    }\n  };\n\n  return { get, set };\n}\n"],"names":["matcher","callback","this","action","_this","$$match","$$callback","Hook","state","$$called","destroyer","$$destroyer","HookLink","scope","$on","initialState","$$state","$$stateHolder","angular","copy","get","set","partialState","key","hasOwnProperty","NgStore","query","Array","isArray","includes","RegExp","TypeError","test","isFunction","hook","$$hooks","push","run","splice","indexOf","newState","filter","matches","forEach"],"mappings":"6LAIA,iBAUE,WAAYA,EAAsBC,GAAlC,WAPQC,eAAW,EAsBZA,aAAU,SAACC,GAAmB,OAAAC,EAAKC,QAAQF,IAdhDD,KAAKG,QAAUL,EACfE,KAAKI,WAAaL,EActB,OANSM,gBAAP,SAAWC,GACTN,KAAKI,WAAWE,GAAQN,KAAKO,UAC7BP,KAAKO,UAAW,qBCjBlB,WAAYC,GACVR,KAAKS,YAAcD,EAmBvB,OAbSE,oBAAP,WACEV,KAAKS,eAOAC,sBAAP,SAAiBC,GAAjB,WACEA,EAAMC,IAAI,WAAY,WACpBV,EAAKO,wCCKT,WAAYI,OClB2BP,EACjCQ,EDWEd,aAA8B,GAiBpCA,KAAKe,eC7BgCT,ED6BNO,EC5B3BC,EAAUE,QAAQC,KAAKX,GActB,CAAEY,IAZG,WACV,OAAOF,QAAQC,KAAKH,IAWRK,IARF,SAACC,GACX,IAAK,IAAMC,KAAOD,EACZA,EAAaE,eAAeD,IAAQA,KAAOP,IAC7CA,EAAQO,GAAOL,QAAQC,KAAKG,EAAaC,QDoIjD,OA3GSE,iBAAP,WACE,OAAOvB,KAAKe,cAAcG,OAQrBK,iBAAP,SAAYC,EAAiCzB,GAA7C,IACMD,SAEJ,GAAqB,iBAAV0B,EACT1B,EAAoB,MAAV0B,EAAgB,WAAM,OAAA,GAAO,SAACvB,GAAW,OAAAA,IAAWuB,QACzD,GAAIC,MAAMC,QAAQF,GAAQ,CAa/B1B,EAAU,SAACG,GAAW,OAAAuB,EAAMG,SAAS1B,QAChC,CAAA,KAAIuB,aAAiBI,QAS1B,MAAM,IAAIC,UAAU,uBARpB/B,EAAU,SAACG,GAAW,OAAAuB,EAAMM,KAAK7B,IAWnC,IAAKe,QAAQe,WAAWhC,GAOtB,MAAM,IAAI8B,UAAU,0BAGtB,IAAMG,EAAO,IAAI3B,EAAYP,EAASC,GAOtC,OALAC,KAAKiC,QAAQC,KAAKF,GAGlBA,EAAKG,IAAInC,KAAKe,cAAcG,OAErB,IAAIR,EAAS,WAClBR,EAAK+B,QAAQG,OAAOlC,EAAK+B,QAAQI,QAAQL,GAAO,MAqB7CT,qBAAP,SAAgBtB,EAAyBK,GACvC,IAAMc,EAA+BJ,QAAQe,WAAWzB,GACnDA,EAA8BN,KAAKe,cAAcG,OAClDZ,EAcJN,KAAKe,cAAcI,IAAIC,GAGvB,IAAMkB,EAAWtC,KAAKe,cAAcG,MAEpClB,KAAKiC,QACFM,OAAO,SAAAP,GAAQ,OAAAA,EAAKQ,QAAQvC,KAC5BwC,QAAQ,SAAAT,GACPA,EAAKG,IAAIG"}